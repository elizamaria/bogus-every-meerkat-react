import { baseUrl as _baseUrl, relativeUrl, resolveUrl } from "./common/url.js";
import { parseTarget, validatePkgName } from "./install/package.js";
import TraceMap from "./trace/tracemap.js";
// @ts-ignore
import { clearCache as clearFetchCache, fetch as _fetch } from "#fetch";
import { ImportMap } from "@jspm/import-map";
import process from "process";
import { SemverRange } from "sver";
import { JspmError } from "./common/err.js";
import { getIntegrity } from "./common/integrity.js";
import { createLogger } from "./common/log.js";
import { Replacer } from "./common/str.js";
import { analyzeHtml } from "./html/analyze.js";
import { getDefaultProviderStrings } from "./providers/index.js";
import * as nodemodules from "./providers/nodemodules.js";
import { Resolver } from "./trace/resolver.js";
// Type exports for users:
export { analyzeHtml };
/**
 * Supports clearing the global fetch cache in Node.js.
 *
 * Example:
 *
 * ```js
 * import { clearCache } from '@jspm/generator';
 * clearCache();
 * ```
 */ export function clearCache() {
    clearFetchCache();
}
/**
 * Generator.
 */ export class Generator {
    /**
   * Add new custom mappings and lock resolutions to the input map
   * of the generator, which are then applied in subsequent installs.
   *
   * @param jsonOrHtml The mappings are parsed as a JSON data object or string, falling back to reading an inline import map from an HTML file.
   * @param mapUrl An optional URL for the map to handle relative resolutions, defaults to generator mapUrl.
   * @param rootUrl An optional root URL for the map to handle root resolutions, defaults to generator rootUrl.
   * @returns The list of modules pinned by this import map or HTML.
   *
   */ async addMappings(jsonOrHtml, mapUrl = this.mapUrl, rootUrl = this.rootUrl, preloads) {
        if (typeof mapUrl === "string") mapUrl = new URL(mapUrl, this.baseUrl);
        if (typeof rootUrl === "string") rootUrl = new URL(rootUrl, this.baseUrl);
        let htmlModules;
        if (typeof jsonOrHtml === "string") {
            try {
                jsonOrHtml = JSON.parse(jsonOrHtml);
            } catch  {
                const analysis = analyzeHtml(jsonOrHtml, mapUrl);
                jsonOrHtml = analysis.map.json || {};
                preloads = (preloads || []).concat(analysis.preloads.map((preload)=>{
                    var _preload_attrs_href;
                    return (_preload_attrs_href = preload.attrs.href) === null || _preload_attrs_href === void 0 ? void 0 : _preload_attrs_href.value;
                }).filter((x)=>x));
                htmlModules = [
                    ...new Set([
                        ...analysis.staticImports,
                        ...analysis.dynamicImports
                    ])
                ];
            }
        }
        await this.traceMap.addInputMap(jsonOrHtml, mapUrl, rootUrl, preloads);
        return htmlModules || [
            ...this.traceMap.pins
        ];
    }
    /**
   * Retrieve the lockfile data from the installer
   */ getLock() {
        return JSON.parse(JSON.stringify(this.traceMap.installer.installs));
    }
    /**
   * Trace and pin a module, installing all dependencies necessary into the map
   * to support its execution including static and dynamic module imports.
   *
   * @deprecated Use "link" instead.
   */ async pin(specifier, parentUrl) {
        return this.link(specifier, parentUrl);
    }
    /**
   * Trace a module, installing all dependencies necessary into the map
   * to support its execution including static and dynamic module imports.
   *
   * @param specifier Module to trace
   * @param parentUrl Optional parent URL
   * @deprecated Use "link" instead.
   */ async traceInstall(specifier, parentUrl) {
        return this.link(specifier, parentUrl);
    }
    /**
   * Link a module, installing all dependencies necessary into the map
   * to support its execution including static and dynamic module imports.
   *
   * @param specifier Module to link
   * @param parentUrl Optional parent URL
   */ async link(specifier, parentUrl) {
        if (typeof specifier === "string") specifier = [
            specifier
        ];
        let error = false;
        if (this.installCnt++ === 0) this.traceMap.startInstall();
        specifier = specifier.map((specifier)=>specifier.replace(/\\/g, "/"));
        await this.traceMap.processInputMap;
        try {
            await Promise.all(specifier.map((specifier)=>this.traceMap.visit(specifier, {
                    installOpts: {
                        freeze: this.freeze,
                        latest: this.latest,
                        mode: "new-prefer-existing"
                    },
                    toplevel: true
                }, parentUrl || this.baseUrl.href)));
            for (const s of specifier){
                if (!this.traceMap.pins.includes(s)) this.traceMap.pins.push(s);
            }
        } catch (e) {
            error = true;
            throw e;
        } finally{
            if (--this.installCnt === 0) {
                const { map , staticDeps , dynamicDeps  } = await this.traceMap.finishInstall();
                this.map = map;
                if (!error) return {
                    staticDeps,
                    dynamicDeps
                };
            }
        }
    }
    /**
   * Links every imported module in the given HTML file, installing all
   * dependencies necessary to support its execution.
   *
   * @param html HTML to link
   * @param htmlUrl URL of the given HTML
   */ async linkHtml(html, htmlUrl) {
        if (Array.isArray(html)) {
            const impts = await Promise.all(html.map((h)=>this.linkHtml(h, htmlUrl)));
            return [
                ...new Set(impts)
            ].reduce((a, b)=>a.concat(b), []);
        }
        let resolvedUrl;
        if (htmlUrl) {
            if (typeof htmlUrl === "string") {
                resolvedUrl = new URL(resolveUrl(htmlUrl, this.mapUrl, this.rootUrl));
            } else {
                resolvedUrl = htmlUrl;
            }
        }
        const analysis = analyzeHtml(html, resolvedUrl);
        const impts = [
            ...new Set([
                ...analysis.staticImports,
                ...analysis.dynamicImports
            ])
        ];
        await Promise.all(impts.map((impt)=>{
            return this.link(impt, resolvedUrl === null || resolvedUrl === void 0 ? void 0 : resolvedUrl.href);
        }));
        return impts;
    }
    /**
   * Generate and inject an import map for an HTML file
   *
   * @deprecated Instead use:
   *   const pins = await generator.addMappings(html, mapUrl, rootUrl);
   *   return await generator.htmlInject(html, { pins, htmlUrl: mapUrl, rootUrl, preload, integrity, whitespace, esModuleShims, comment });
   *
   * Traces the module scripts of the HTML via link and install
   * for URL-like specifiers and bare specifiers respectively.
   *
   * Injects the final generated import map returning the injected HTML
   *
   * @param html String
   * @param injectOptions Injection options
   *
   * Injection options are: `htmlUrl`, `preload`, `integrity`, `whitespace`
   * and `esModuleShims`. The default is `{ esModuleShims: true, whitespace: true }`.
   *
   * ES Module shims will be resolved to the latest version against the provider
   *
   * Example:
   *
   * ```js
   *  const outputHtml = await generator.htmlGenerate(`
   *    <!doctype html>
   *    <script type="module">import 'react'</script>
   *  `);
   * ```
   *
   * which outputs:
   *
   * ```
   *   <!doctype html>
   *   <!-- Generated by @jspm/generator - https://github.com/jspm/generator -->
   *   <script async src="https://ga.jspm.io/npm:es-module-shims@1.4.1/dist/es-module-shims.js"></script>
   *   <script type="importmap">
   *   {...}
   *   </script>
   *   <script type="module">import 'react'</script>
   * ```
   *
   */ async htmlGenerate(html, { mapUrl , rootUrl , preload =false , integrity =false , whitespace =true , esModuleShims =true , comment =true  } = {}) {
        if (typeof mapUrl === "string") mapUrl = new URL(mapUrl);
        const pins = await this.addMappings(html, mapUrl, rootUrl);
        return await this.htmlInject(html, {
            pins,
            htmlUrl: mapUrl,
            rootUrl,
            preload,
            integrity,
            whitespace,
            esModuleShims,
            comment
        });
    }
    /**
   * Inject the import map into the provided HTML source
   *
   * @param html HTML source to inject into
   * @param opts Injection options
   * @returns HTML source with import map injection
   */ async htmlInject(html, { trace =false , pins =!trace , htmlUrl , rootUrl , preload =false , integrity =false , whitespace =true , esModuleShims =true , comment =true  } = {}) {
        if (comment === true) comment = " Generated by @jspm/generator - https://github.com/jspm/generator ";
        if (typeof htmlUrl === "string") htmlUrl = new URL(htmlUrl);
        if (integrity) preload = true;
        if (this.installCnt !== 0) throw new JspmError("htmlGenerate cannot run alongside other install ops");
        const analysis = analyzeHtml(html, htmlUrl);
        let modules = pins === true ? this.traceMap.pins : Array.isArray(pins) ? pins : [];
        if (trace) {
            const impts = await this.linkHtml(html, htmlUrl);
            modules = [
                ...new Set([
                    ...modules,
                    ...impts
                ])
            ];
        }
        const { map , staticDeps , dynamicDeps  } = await this.extractMap(modules, htmlUrl, rootUrl);
        const preloadDeps = preload === true && integrity || preload === "all" ? [
            ...new Set([
                ...staticDeps,
                ...dynamicDeps
            ])
        ] : staticDeps;
        const newlineTab = !whitespace ? analysis.newlineTab : analysis.newlineTab.includes("\n") ? analysis.newlineTab : "\n" + analysis.newlineTab;
        const replacer = new Replacer(html);
        let esms = "";
        if (esModuleShims) {
            let esmsPkg;
            try {
                esmsPkg = await this.traceMap.resolver.resolveLatestTarget({
                    name: "es-module-shims",
                    registry: "npm",
                    ranges: [
                        new SemverRange("*")
                    ],
                    unstable: false
                }, this.traceMap.installer.defaultProvider, this.baseUrl.href);
            } catch (err) {
                // This usually happens because the user is trying to use their
                // node_modules as the provider but has not installed the shim:
                let errMsg = `Unable to resolve "es-module-shims@*" under current provider "${this.traceMap.installer.defaultProvider.provider}".`;
                if (this.traceMap.installer.defaultProvider.provider === "nodemodules") {
                    errMsg += `\n\nJspm automatically injects a shim so that the import map in your HTML file will be usable by older browsers.\nYou may need to run "npm install es-module-shims" to install the shim if you want to link against your local node_modules folder.`;
                }
                errMsg += `\nTo disable the import maps polyfill injection, set esModuleShims: false.`;
                throw new JspmError(errMsg);
            }
            let esmsUrl = await this.traceMap.resolver.pkgToUrl(esmsPkg, this.traceMap.installer.defaultProvider) + "dist/es-module-shims.js";
            if (htmlUrl || rootUrl) esmsUrl = relativeUrl(new URL(esmsUrl), new URL(rootUrl !== null && rootUrl !== void 0 ? rootUrl : htmlUrl), !!rootUrl);
            esms = `<script async src="${esmsUrl}" crossorigin="anonymous"${integrity ? ` integrity="${await getIntegrity(esmsUrl, this.traceMap.resolver.fetchOpts)}"` : ""}></script>${newlineTab}`;
            if (analysis.esModuleShims) replacer.remove(analysis.esModuleShims.start, analysis.esModuleShims.end, true);
        }
        for (const preload of analysis.preloads){
            replacer.remove(preload.start, preload.end, true);
        }
        let preloads = "";
        if (preload && preloadDeps.length) {
            let first = true;
            for (let dep of preloadDeps.sort()){
                if (first || whitespace) preloads += newlineTab;
                if (first) first = false;
                if (integrity) {
                    preloads += `<link rel="modulepreload" href="${rootUrl || htmlUrl ? relativeUrl(new URL(dep), new URL(rootUrl !== null && rootUrl !== void 0 ? rootUrl : htmlUrl), !!rootUrl) : dep}" integrity="${await getIntegrity(dep, this.traceMap.resolver.fetchOpts)}" />`;
                } else {
                    preloads += `<link rel="modulepreload" href="${rootUrl || htmlUrl ? relativeUrl(new URL(dep), new URL(rootUrl !== null && rootUrl !== void 0 ? rootUrl : htmlUrl), !!rootUrl) : dep}" />`;
                }
            }
        }
        // when applying integrity, all existing script tags have their integrity updated
        if (integrity) {
            for (const module of analysis.modules){
                if (!module.attrs.src) continue;
                if (module.attrs.integrity) {
                    replacer.remove(module.attrs.integrity.start - (replacer.source[replacer.idx(module.attrs.integrity.start - 1)] === " " ? 1 : 0), module.attrs.integrity.end + 1);
                }
                const lastAttr = Object.keys(module.attrs).filter((attr)=>attr !== "integrity").sort((a, b)=>module.attrs[a].end > module.attrs[b].end ? -1 : 1)[0];
                replacer.replace(module.attrs[lastAttr].end + 1, module.attrs[lastAttr].end + 1, ` integrity="${await getIntegrity(resolveUrl(module.attrs.src.value, this.mapUrl, this.rootUrl), this.traceMap.resolver.fetchOpts)}"`);
            }
        }
        if (comment) {
            const existingComment = analysis.comments.find((c)=>replacer.source.slice(replacer.idx(c.start), replacer.idx(c.end)).includes(comment));
            if (existingComment) {
                replacer.remove(existingComment.start, existingComment.end, true);
            }
        }
        replacer.replace(analysis.map.start, analysis.map.end, (comment ? "<!--" + comment + "-->" + newlineTab : "") + esms + '<script type="importmap">' + (whitespace ? newlineTab : "") + JSON.stringify(map, null, whitespace ? 2 : 0).replace(/\n/g, newlineTab) + (whitespace ? newlineTab : "") + "</script>" + preloads + (analysis.map.newScript ? newlineTab : ""));
        return replacer.source;
    }
    /**
   * Install a package target into the import map, including all its dependency resolutions via tracing.
   *
   * @param install Package or list of packages to install into the import map.
   *
   * For example:
   *
   * ```js
   * // Install a new package into the import map
   * await generator.install('react-dom');
   *
   * // Install a package version and subpath into the import map (installs lit/decorators.js)
   * await generator.install('lit@2/decorators.js');
   *
   * // Install a package version to a custom alias
   * await generator.install({ alias: 'react16', target: 'react@16' });
   *
   * // Install a specific subpath of a package
   * await generator.install({ target: 'lit@2', subpath: './html.js' });
   *
   * // Install an export from a locally located package folder into the map
   * // The package.json is used to determine the exports and dependencies.
   * await generator.install({ alias: 'mypkg', target: './packages/local-pkg', subpath: './feature' });
   * ```
   */ async install(install) {
        if (arguments.length > 1) throw new JspmError("Install takes no arguments, a single install target, or a list of install targets.");
        // If there are no arguments, install all top-level pins.
        if (!install) {
            await this.traceMap.processInputMap;
            return this.install(this.traceMap.pins);
        }
        // Split the case of multiple install targets:
        if (Array.isArray(install)) return await Promise.all(install.map((install)=>this.install(install))).then((installs)=>installs.find((i)=>i));
        // Split the case of multiple install subpaths:
        if (typeof install !== "string" && install.subpaths !== undefined) {
            install.subpaths.every((subpath)=>{
                if (typeof subpath !== "string" || subpath !== "." && !subpath.startsWith("./")) throw new Error(`Install subpath "${subpath}" must be equal to "." or start with "./".`);
            });
            return await Promise.all(install.subpaths.map((subpath)=>this.install({
                    target: install.target,
                    alias: install.alias,
                    subpath
                }))).then((installs)=>installs.find((i)=>i));
        }
        // Handle case of a single install target with at most one subpath:
        let error = false;
        if (this.installCnt++ === 0) this.traceMap.startInstall();
        await this.traceMap.processInputMap; // don't race input processing
        try {
            // Resolve input information to a target package:
            let alias, target, subpath;
            if (typeof install === "string" || typeof install.target === "string") {
                ({ alias , target , subpath  } = await installToTarget.call(this, install, this.traceMap.installer.defaultRegistry));
            } else {
                ({ alias , target , subpath  } = install);
                validatePkgName(alias);
            }
            // Trace the target package and it's secondary dependencies:
            this.log("generator/install", `Adding primary constraint for ${alias}: ${JSON.stringify(target)}`);
            var _this_latest;
            // Always install latest unless "freeze" is set or the user has set
            // the deprecated "latest" flag explicitly:
            const installLatest = (_this_latest = this.latest) !== null && _this_latest !== void 0 ? _this_latest : this.freeze ? false : true;
            await this.traceMap.add(alias, target, this.freeze, installLatest);
            await this.traceMap.visit(alias + subpath.slice(1), {
                installOpts: {
                    freeze: this.freeze,
                    latest: installLatest,
                    mode: "new"
                },
                toplevel: true
            }, this.mapUrl.href);
            // Add the target package as a top-level pin:
            if (!this.traceMap.pins.includes(alias + subpath.slice(1))) this.traceMap.pins.push(alias + subpath.slice(1));
        } catch (e) {
            error = true;
            throw e;
        } finally{
            if (--this.installCnt === 0) {
                const { map , staticDeps , dynamicDeps  } = await this.traceMap.finishInstall();
                this.map = map;
                if (!error) return {
                    staticDeps,
                    dynamicDeps
                };
            }
        }
    }
    /**
   * Locking install, retraces all top-level pins but does not change the
   * versions of anything (similar to "npm ci").
   *
   * @deprecated Use install() with the "freeze: true" option.
   */ async reinstall() {
        if (this.installCnt++ === 0) this.traceMap.startInstall();
        await this.traceMap.processInputMap;
        if (--this.installCnt === 0) {
            const { map , staticDeps , dynamicDeps  } = await this.traceMap.finishInstall();
            this.map = map;
            return {
                staticDeps,
                dynamicDeps
            };
        }
    }
    async update(pkgNames) {
        if (typeof pkgNames === "string") pkgNames = [
            pkgNames
        ];
        if (this.installCnt++ === 0) this.traceMap.startInstall();
        await this.traceMap.processInputMap;
        const primaryResolutions = this.traceMap.installer.installs.primary;
        const primaryConstraints = this.traceMap.installer.constraints.primary;
        if (!pkgNames) pkgNames = Object.keys(primaryResolutions);
        const installs = [];
        for (const name of pkgNames){
            const resolution = primaryResolutions[name];
            if (!resolution) {
                this.installCnt--;
                throw new JspmError(`No "imports" package entry for "${name}" to update. Note update takes package names not package specifiers.`);
            }
            const { installUrl , installSubpath  } = resolution;
            const subpaths = this.traceMap.pins.filter((pin)=>pin === name || pin.startsWith(name) && pin[name.length] === "/").map((pin)=>`.${pin.slice(name.length)}`);
            // use package.json range if present
            if (primaryConstraints[name]) {
                installs.push({
                    alias: name,
                    subpaths,
                    target: {
                        pkgTarget: primaryConstraints[name],
                        installSubpath
                    }
                });
            } else {
                const pkg = await this.traceMap.resolver.parseUrlPkg(installUrl);
                if (!pkg) throw new Error(`Unable to determine a package version lookup for ${name}. Make sure it is supported as a provider package.`);
                const target = {
                    pkgTarget: {
                        registry: pkg.pkg.registry,
                        name: pkg.pkg.name,
                        ranges: [
                            new SemverRange("^" + pkg.pkg.version)
                        ],
                        unstable: false
                    },
                    installSubpath
                };
                installs.push({
                    alias: name,
                    subpaths,
                    target
                });
            }
        }
        await this.install(installs);
        if (--this.installCnt === 0) {
            const { map , staticDeps , dynamicDeps  } = await this.traceMap.finishInstall();
            this.map = map;
            return {
                staticDeps,
                dynamicDeps
            };
        }
    }
    async uninstall(names) {
        if (typeof names === "string") names = [
            names
        ];
        if (this.installCnt++ === 0) {
            this.traceMap.startInstall();
        }
        await this.traceMap.processInputMap;
        let pins = this.traceMap.pins;
        const unusedNames = new Set([
            ...names
        ]);
        for(let i = 0; i < pins.length; i++){
            const pin = pins[i];
            const pinNames = names.filter((name)=>name === pin || name.endsWith("/") && pin.startsWith(name));
            if (pinNames.length) {
                pins.splice(i--, 1);
                for (const name of pinNames)unusedNames.delete(name);
            }
        }
        if (unusedNames.size) {
            this.installCnt--;
            throw new JspmError(`No "imports" entry for "${[
                ...unusedNames
            ][0]}" to uninstall.`);
        }
        this.traceMap.pins = pins;
        if (--this.installCnt === 0) {
            const { map  } = await this.traceMap.finishInstall();
            this.map = map;
        }
    }
    async extractMap(pins, mapUrl, rootUrl) {
        if (typeof mapUrl === "string") mapUrl = new URL(mapUrl, this.baseUrl);
        if (typeof rootUrl === "string") rootUrl = new URL(rootUrl, this.baseUrl);
        if (!Array.isArray(pins)) pins = [
            pins
        ];
        if (this.installCnt++ !== 0) throw new JspmError(`Cannot run extract map during installs`);
        this.traceMap.startInstall();
        await this.traceMap.processInputMap;
        if (--this.installCnt !== 0) throw new JspmError(`Another install was started during extract map.`);
        const { map , staticDeps , dynamicDeps  } = await this.traceMap.finishInstall(pins);
        map.rebase(mapUrl, rootUrl);
        map.flatten();
        map.sort();
        map.combineSubpaths();
        return {
            map: map.toJSON(),
            staticDeps,
            dynamicDeps
        };
    }
    /**
   * Resolve a specifier using the import map.
   *
   * @param specifier Module to resolve
   * @param parentUrl ParentURL of module to resolve
   * @returns Resolved URL string
   */ resolve(specifier, parentUrl = this.baseUrl) {
        if (typeof parentUrl === "string") parentUrl = new URL(parentUrl, this.baseUrl);
        const resolved = this.map.resolve(specifier, parentUrl);
        if (resolved === null) throw new JspmError(`Unable to resolve "${specifier}" from ${parentUrl.href}`, "MODULE_NOT_FOUND");
        return resolved;
    }
    /**
   * Get the import map JSON
   */ get importMap() {
        return this.map;
    }
    /**
   *
   * @param url
   * @returns
   */ getAnalysis(url) {
        if (typeof url !== "string") url = url.href;
        const trace = this.traceMap.tracedUrls[url];
        if (!trace) throw new Error(`The URL ${url} has not been traced by this generator instance.`);
        return {
            format: trace.format,
            staticDeps: trace.deps,
            dynamicDeps: trace.dynamicDeps,
            cjsLazyDeps: trace.cjsLazyDeps || []
        };
    }
    getMap(mapUrl, rootUrl) {
        const map = this.map.clone();
        map.rebase(mapUrl, rootUrl);
        map.flatten();
        map.sort();
        map.combineSubpaths();
        return map.toJSON();
    }
    /**
   * Constructs a new Generator instance.
   *
   * For example:
   *
   * ```js
   * const generator = new Generator({
   *   mapUrl: import.meta.url,
   *   inputMap: {
   *     "imports": {
   *       "react": "https://cdn.skypack.dev/react"
   *     }
   *   },
   *   defaultProvider: 'jspm',
   *   defaultRegistry: 'npm',
   *   providers: {
   *     '@orgscope': 'nodemodules'
   *   },
   *   customProviders: {},
   *   env: ['production', 'browser'],
   *   cache: false,
   * });
   * ```
   */ constructor({ baseUrl , mapUrl , rootUrl =undefined , inputMap =undefined , env =[
        "browser",
        "development",
        "module",
        "import"
    ] , defaultProvider , defaultRegistry ="npm" , customProviders =undefined , providers , resolutions ={} , cache =true , ignore =[] , freeze , latest , ipfsAPI , commonJS =false  } = {}){
        /**
   * The number of concurrent installs the generator is busy processing.
   */ this.installCnt = 0;
        // Initialise the debug logger:
        const { log , logStream  } = createLogger();
        this.log = log;
        this.logStream = logStream;
        if (process.env.JSPM_GENERATOR_LOG) {
            (async ()=>{
                for await (const { type , message  } of this.logStream()){
                    console.log(`\x1b[1m${type}:\x1b[0m ${message}`);
                }
            })();
        }
        // Initialise the resource fetcher:
        let fetchOpts;
        if (cache === "offline") fetchOpts = {
            cache: "force-cache",
            headers: {
                "Accept-Encoding": "gzip, br"
            }
        };
        else if (!cache) fetchOpts = {
            cache: "no-store",
            headers: {
                "Accept-Encoding": "gzip, br"
            }
        };
        else fetchOpts = {
            headers: {
                "Accept-Encoding": "gzip, br"
            }
        };
        if (ipfsAPI) fetchOpts.ipfsAPI = ipfsAPI;
        // Default logic for the mapUrl, baseUrl and rootUrl:
        if (mapUrl && !baseUrl) {
            mapUrl = typeof mapUrl === "string" ? new URL(mapUrl, _baseUrl) : mapUrl;
            try {
                baseUrl = new URL("./", mapUrl);
            } catch  {
                baseUrl = new URL(mapUrl + "/");
            }
        } else if (baseUrl && !mapUrl) {
            mapUrl = baseUrl;
        } else if (!mapUrl && !baseUrl) {
            baseUrl = mapUrl = _baseUrl;
        }
        this.baseUrl = typeof baseUrl === "string" ? new URL(baseUrl, _baseUrl) : baseUrl;
        if (!this.baseUrl.pathname.endsWith("/")) {
            this.baseUrl = new URL(this.baseUrl.href);
            this.baseUrl.pathname += "/";
        }
        this.mapUrl = typeof mapUrl === "string" ? new URL(mapUrl, this.baseUrl) : mapUrl;
        this.rootUrl = typeof rootUrl === "string" ? new URL(rootUrl, this.baseUrl) : rootUrl || null;
        if (this.rootUrl && !this.rootUrl.pathname.endsWith("/")) this.rootUrl.pathname += "/";
        if (!this.mapUrl.pathname.endsWith("/")) {
            try {
                this.mapUrl = new URL("./", this.mapUrl);
            } catch  {
                this.mapUrl = new URL(this.mapUrl.href + "/");
            }
        }
        // Initialise the resolver:
        const resolver = new Resolver(env, log, fetchOpts, true);
        if (customProviders) {
            for (const provider of Object.keys(customProviders)){
                resolver.addCustomProvider(provider, customProviders[provider]);
            }
        }
        // The node_modules provider is special, because it needs to be rooted to
        // perform resolutions against the local node_modules directory:
        const nmProvider = nodemodules.createProvider(this.baseUrl.href, defaultProvider === "nodemodules");
        resolver.addCustomProvider("nodemodules", nmProvider);
        // We make an attempt to auto-detect the default provider from the input
        // map, by picking the provider with the most owned URLs:
        defaultProvider = detectDefaultProvider(defaultProvider, inputMap, resolver);
        // Initialise the tracer:
        this.traceMap = new TraceMap({
            mapUrl: this.mapUrl,
            rootUrl: this.rootUrl,
            baseUrl: this.baseUrl,
            defaultProvider,
            defaultRegistry,
            providers,
            ignore,
            resolutions,
            commonJS
        }, log, resolver);
        // Reconstruct constraints and locks from the input map:
        this.map = new ImportMap({
            mapUrl: this.mapUrl,
            rootUrl: this.rootUrl
        });
        if (inputMap) this.addMappings(inputMap);
        // Set global installation options:
        this.latest = latest;
        this.freeze = freeze;
    }
}
/**
 * _Use the internal fetch implementation, useful for hooking into the same shared local fetch cache._
 *
 * ```js
 * import { fetch } from '@jspm/generator';
 *
 * const res = await fetch(url);
 * console.log(await res.text());
 * ```
 *
 * Use the `{ cache: 'no-store' }` option to disable the cache, and the `{ cache: 'force-cache' }` option to enforce the offline cache.
 */ export async function fetch(url, opts = {}) {
    // @ts-ignore
    return _fetch(url, opts);
}
/**
 * Get the lookup resolution information for a specific install.
 *
 * @param install The install object
 * @param lookupOptions Provider and cache defaults for lookup
 * @returns The resolved install and exact package { install, resolved }
 */ export async function lookup(install, { provider , cache  } = {}) {
    const generator = new Generator({
        cache: !cache,
        defaultProvider: provider
    });
    const { target , subpath , alias  } = await installToTarget.call(generator, install, generator.traceMap.installer.defaultRegistry);
    if (typeof target === "string") throw new Error(`Resolved install "${install}" to package specifier ${target}, but expected a fully qualified install target.`);
    const { pkgTarget , installSubpath  } = target;
    if (pkgTarget instanceof URL) throw new Error("URL lookups not supported");
    const resolved = await generator.traceMap.resolver.resolveLatestTarget(pkgTarget, generator.traceMap.installer.getProvider(pkgTarget), generator.baseUrl.href);
    return {
        install: {
            target: {
                registry: pkgTarget.registry,
                name: pkgTarget.name,
                range: pkgTarget.ranges.map((range)=>range.toString()).join(" || ")
            },
            installSubpath,
            subpath,
            alias
        },
        resolved: resolved
    };
}
/**
 * Get the package.json configuration for a specific URL or package.
 *
 * @param pkg Package to lookup configuration for
 * @param lookupOptions Optional provider and cache defaults for lookup
 * @returns Package JSON configuration
 *
 * Example:
 * ```js
 * import { getPackageConfig } from '@jspm/generator';
 *
 * // Supports a resolved package
 * {
 *   const packageJson = await getPackageConfig({ registry: 'npm', name: 'lit-element', version: '2.5.1' });
 * }
 *
 * // Or alternatively provide any URL
 * {
 *   const packageJson = await getPackageConfig('https://ga.jspm.io/npm:lit-element@2.5.1/lit-element.js');
 * }
 * ```
 */ export async function getPackageConfig(pkg, { provider , cache  } = {}) {
    const generator = new Generator({
        cache: !cache,
        defaultProvider: provider
    });
    if (typeof pkg === "object" && "name" in pkg) pkg = await generator.traceMap.resolver.pkgToUrl(pkg, generator.traceMap.installer.defaultProvider);
    else if (typeof pkg === "string") pkg = new URL(pkg).href;
    else pkg = pkg.href;
    return generator.traceMap.resolver.getPackageConfig(pkg);
}
/**
 * Get the package base URL for the given module URL.
 *
 * @param url module URL
 * @param lookupOptions Optional provider and cache defaults for lookup
 * @returns Base package URL
 *
 * Modules can be remote CDN URLs or local file:/// URLs.
 *
 * All modules in JSPM are resolved as within a package boundary, which is the
 * parent path of the package containing a package.json file.
 *
 * For JSPM CDN this will always be the base of the package as defined by the
 * JSPM CDN provider. For non-provider-defined origins it is always determined
 * by trying to fetch the package.json in each parent path until the root is reached
 * or one is found. On file:/// URLs this exactly matches the Node.js resolution
 * algorithm boundary lookup.
 *
 * This package.json file controls the package name, imports resolution, dependency
 * resolutions and other package information.
 *
 * getPackageBase will return the folder containing the package.json,
 * with a trailing '/'.
 *
 * This URL will either be the root URL of the origin, or it will be a
 * path "pkgBase" such that fetch(`${pkgBase}package.json`) is an existing
 * package.json file.
 *
 * For example:
 *
 * ```js
 *   import { getPackageBase } from '@jspm/generator';
 *   const pkgUrl = await getPackageBase('https://ga.jspm.io/npm:lit-element@2.5.1/lit-element.js');
 *   // Returns: https://ga.jspm.io/npm:lit-element@2.5.1/
 * ```
 */ export async function getPackageBase(url, { provider , cache  } = {}) {
    const generator = new Generator({
        cache: !cache,
        defaultProvider: provider
    });
    return generator.traceMap.resolver.getPackageBase(typeof url === "string" ? url : url.href);
}
/**
 * Get the package metadata for the given module or package URL.
 *
 * @param url URL of a module or package for a configured provider.
 * @param lookupOptions Optional provider and cache defaults for lookup.
 * @returns Package metadata for the given URL if one of the configured
 *          providers owns it, else null.
 *
 * The returned metadata will always contain the package name, version and
 * registry, along with the provider name and layer that handles resolution
 * for the given URL.
 */ export async function parseUrlPkg(url, { provider , cache  } = {}) {
    const generator = new Generator({
        cache: !cache,
        defaultProvider: provider
    });
    return generator.traceMap.resolver.parseUrlPkg(typeof url === "string" ? url : url.href);
}
/**
 * Returns a list of providers that are supported by default.
 *
 * @returns List of valid provider strings supported by default.
 *
 * To use one of these providers, pass the string to either the "defaultProvider"
 * option or the "providers" mapping when constructing a Generator.
 */ export function getDefaultProviders() {
    return getDefaultProviderStrings();
}
async function installToTarget(install, defaultRegistry) {
    if (typeof install === "string") install = {
        target: install
    };
    if (typeof install.target !== "string") throw new Error('All installs require a "target" string.');
    if (install.subpath !== undefined && (typeof install.subpath !== "string" || install.subpath !== "." && !install.subpath.startsWith("./"))) throw new Error(`Install subpath "${install.subpath}" must be a string equal to "." or starting with "./".${typeof install.subpath === "string" ? `\nTry setting the subpath to "./${install.subpath}"` : ""}`);
    const { alias , target , subpath  } = await parseTarget(this.traceMap.resolver, install.target, this.baseUrl, defaultRegistry);
    return {
        target,
        alias: install.alias || alias,
        subpath: install.subpath || subpath
    };
}
function detectDefaultProvider(defaultProvider, inputMap, resolver) {
    // We only use top-level install information to detect the provider:
    const counts = {};
    for (const url of Object.values((inputMap === null || inputMap === void 0 ? void 0 : inputMap.imports) || {})){
        const name = resolver.providerNameForUrl(url);
        if (name) {
            counts[name] = (counts[name] || 0) + 1;
        }
    }
    let winner;
    let winnerCount = 0;
    for (const [name, count] of Object.entries(counts)){
        if (count > winnerCount) {
            winner = name;
            winnerCount = count;
        }
    }
    // TODO: this should be the behaviour once we support full 'providers' opt
    // The leading provider in the input map takes precedence as the provider of
    // the root package. Failing that, the user-provided default is used. The
    // 'providers' field can be used for hard-overriding this:
    // return winner || defaultProvider || "jspm.io";
    return defaultProvider || winner || "jspm.io";
}


//# sourceMappingURL=generator.js.map