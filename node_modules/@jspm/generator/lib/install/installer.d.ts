import { Log } from "../common/log.js";
import { Resolver } from "../trace/resolver.js";
import { PackageTarget } from "./package.js";
import { InstalledResolution, LockResolutions, VersionConstraints } from "./lock.js";
export interface PackageProvider {
    provider: string;
    layer: string;
}
export type ResolutionMode = "new" | "new-prefer-existing" | "existing";
/**
 * InstallOptions configures the interaction between the Installer and the
 * existing lockfile during an install operation.
 */
export interface InstallOptions {
    mode: ResolutionMode;
    freeze?: boolean;
    latest?: boolean;
}
export type InstallTarget = {
    pkgTarget: PackageTarget | URL;
    installSubpath: null | `./${string}`;
};
export interface InstallerOptions {
    mapUrl: URL;
    baseUrl: URL;
    rootUrl?: URL | null;
    lock?: LockResolutions;
    reset?: boolean;
    prune?: boolean;
    save?: boolean;
    saveDev?: boolean;
    savePeer?: boolean;
    saveOptional?: boolean;
    resolutions?: Record<string, string>;
    defaultProvider?: string;
    defaultRegistry?: string;
    providers?: Record<string, string>;
}
export declare class Installer {
    opts: InstallerOptions;
    installs: LockResolutions;
    constraints: VersionConstraints;
    installing: boolean;
    newInstalls: boolean;
    installBaseUrl: `${string}/`;
    added: Map<string, InstallTarget>;
    hasLock: boolean;
    defaultProvider: {
        provider: string;
        layer: string;
    };
    defaultRegistry: string;
    providers: Record<string, string>;
    resolutions: Record<string, string>;
    log: Log;
    resolver: Resolver;
    constructor(baseUrl: `${string}/`, opts: InstallerOptions, log: Log, resolver: Resolver);
    visitInstalls(visitor: (scope: Record<string, InstalledResolution>, scopeUrl: string | null) => boolean | void): void;
    startInstall(): void;
    finishInstall(): void;
    getProvider(target: PackageTarget): {
        provider: string;
        layer: string;
    };
    /**
     * Locks a package against the given target.
     *
     * @param {string} pkgName Name of the package being installed.
     * @param {InstallTarget} target The installation target being installed.
     * @param {`./${string}` | '.'} traceSubpath
     * @param {InstallOptions} opts Specifies how to interact with existing installs.
     * @param {`${string}/` | null} pkgScope URL of the package scope in which this install is occurring, null if it's a top-level install.
     * @param {string} parentUrl URL of the parent for this install.
     * @returns {Promise<InstalledResolution>}
     */
    installTarget(pkgName: string, { pkgTarget, installSubpath }: InstallTarget, traceSubpath: `./${string}` | ".", opts: InstallOptions, pkgScope: `${string}/` | null, parentUrl: string): Promise<InstalledResolution>;
    /**
     * Installs the given package specifier.
     *
     * @param {string} pkgName The package specifier being installed.
     * @param {InstallOptions} opts Specifies how to interact with existing installs.
     * @param {`${string}/` | null} pkgScope URL of the package scope in which this install is occurring, null if it's a top-level install.
     * @param {`./${string}` | '.'} traceSubpath
     * @param {string} parentUrl URL of the parent for this install.
     * @returns {Promise<string | InstalledResolution>}
     */
    install(pkgName: string, opts: InstallOptions, pkgScope: `${string}/` | null, traceSubpath: `./${string}` | ".", parentUrl?: string): Promise<string | InstalledResolution>;
    private get pkgUrls();
    private getBestExistingMatch;
    private inRange;
    private tryUpgradeAllTo;
    private upgradeSupportedTo;
}
